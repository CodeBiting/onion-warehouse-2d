doctype html
html(lang="en")
    head
        meta(charset="UTF-8")
        title 2D Map with Pixi.js
        script(src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.4/browser/pixi.min.js" integrity="sha512-MLJM72M8frjnFXEvWn3NaVkrSxlDnbRK/Iwyr7loPca+13SdS9B5sNLHoIkDxfPOndP8WReNdwGLxisYUapc7A==" crossorigin="anonymous" referrerpolicy="no-referrer")
        script(src="https://cdn.jsdelivr.net/npm/pixi-viewport@4.30.0/dist/viewport.min.js")
        script(src="https://cdn.jsdelivr.net/npm/chart.js")
        script(src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels")

        style.
            body {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 10px;
                font-family: Arial, sans-serif;
                background-color: #f0f0f0;
                margin: 0;
                padding: 0;
                height: 100vh;
                box-sizing: border-box;
            }

            #header {
                text-align: center;
                margin-top: 20px;
            }

            #main-container {
                display: flex;
                flex-direction: column;
                gap: 20px;
                width: 90%;
                margin-top: 20px;
                flex: 1;
            }

            #charts-container {
                display: flex;
                flex-direction: row;
                gap: 10px;
                align-items: flex-start;
                justify-content: center;
                margin-bottom: 20px;
                width: 100%;
            }

            .chart-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                flex: 1;
                max-width: 30%;
                height: 200px;
            }

            .chart-container div {
                margin-bottom: 5px;
                font-size: 1em;
                font-weight: bold;
            }

            .chart-container canvas {
                width: 100%;
                height: auto;
            }

            @media (min-width: 768px) {
                #main-container {
                    flex-direction: row;
                }

                #left-panel {
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    flex: 1;
                    position: relative;
                }

                #right-panel {
                    flex: 2;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                }
            }

            #left-panel {
                display: flex;
                flex-direction: column;
                gap: 10px;
                flex: 1;
                position: relative;
            }

            #right-panel {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
            }

            #autocomplete-container {
                position: relative;
                width: 100%;
            }

            #autocomplete-results {
                position: absolute;
                width: 100%;
                top: 35px;
                left: 0;
                right: 0;
                z-index: 1000;
                border: 1px solid #ddd;
                background: #fff;
                list-style-type: none;
                padding: 0;
                margin: 0;
                max-height: 120px;
                overflow-y: auto;
            }

            #autocomplete-results li {
                padding: 5px 10px;
                cursor: pointer;
            }

            #autocomplete-results li:hover {
                background-color: #f0f0f0;
            }

            #buttons {
                display: flex;
                gap: 10px;
                margin-top: 15px;
                flex-wrap: wrap;
            }

           #location-details, #user-details {
                display: inline-block; /* Para mostrar ambos contenedores en línea */
                vertical-align: top;   /* Alinear ambos contenedores en la parte superior */
                max-height: 500px;
                overflow-y: auto;
                border: 3px solid #ccc;
                padding: 10px;
                width: 60%;           /* Ajustar el ancho al contenido de la tabla */
            }

            #location-details {
                margin-right: 10px;    /* Espacio entre los dos contenedores */
            }

            #location-details table, #user-details table {
                width: 100%;
                border-collapse: collapse;
            }

            #location-details th, #user-details th, #location-details td, #user-details td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: center;
            }

            #location-details tr:nth-child(even), #user-details tr:nth-child(even) {
                background-color: #f2f2f2;
            }

            #location-details th, #user-details th {
                background-color: #4CAF50;
                color: white;
            }

            #pixi-canvas-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
                margin-top: 5%;
                margin-bottom: 10%;
                flex: 1;
            }

            canvas {
                width: 100%;
                height: auto;
                max-width: 800px;
                max-height: 500px;
                transition: width 0.5s, height 0.5s;
            }

            #container-right-panel {
                display: flex;
                flex-direction: column;
                flex: 2;
            }


    body
        #header
            h1 Warehouse Map

        #main-container
            #left-panel
                #autocomplete-container
                    input(type="text" id="productCode" placeholder="Enter product code" oninput="autocompleteSearch()")
                    ul#autocomplete-results
                    button(onclick="searchProduct()") Search

                #state-selector-container
                    select#state-selector
                    button(onclick="highlightLocationsByState()") Highlight Locations
                    span#state-count

                #buttons
                    button(onclick="searchProduct()") Search
                    button#zoomIn Zoom In
                    button#zoomOut Zoom Out
                #location-details
                    table
                        thead
                            tr
                                th Location Code
                                th Parent Code
                                th Position
                                th Inside
                        tbody

            #container-right-panel
                #charts-container
                    .chart-container
                        div Orders
                        canvas#ordersChart
                    .chart-container
                        div Tasks
                        canvas#tasksChart
                    .chart-container
                        div Users Task
                        canvas#usersTasksChart

        #pixi-canvas-container
            #location-details
                table
                    thead
                        tr
                            th Location Code
                            th Parent Code
                            th Position
                            th Inside
                    tbody
            #titleInfo
                h2 Details
        #pixi-canvas-container
            #user-details
               
                #right-panel  <!-- cambios de Leo -->
                    #pixi-canvas-container

        script.
            const transformedData = transformData(!{JSON.stringify(data)});
            const products = !{JSON.stringify(productsData)};
            const stocks = !{JSON.stringify(stocksData)};
            const placeStatusTypes = !{JSON.stringify(placeStatusTypesData)};
            const workload = !{JSON.stringify(workload)};

            console.log(transformedData);
            console.log(workload)

            const app = new PIXI.Application({
                width: 600,
                height: 300,
                backgroundColor: 0xffffff,
            });
            const canvasContainer = document.getElementById('pixi-canvas-container');
            canvasContainer.appendChild(app.view);

            app.view.style.border = '4px solid #000000';

            const viewport = new PIXI.Viewport({
                screenWidth: 600,
                screenHeight: 300,
                worldWidth: 1000,
                worldHeight: 600,
                interaction: app.renderer.plugins.interaction
            });

            app.stage.addChild(viewport);

            viewport.drag().pinch().wheel().decelerate();

            const mapContainer = new PIXI.Container();
            viewport.addChild(mapContainer);

            let highlightedSquare = null;

            function createSquare (x, z, highlight = false, type = "default" , color = 0xffffff, locationId = null, statusIds = []) {
                const square = new PIXI.Container();
                square.x = x * 25;
                square.y = z * 25;
                square.locationId = locationId;
                square.statusIds = statusIds; 
                square.interactive = true;
                square.on('pointerdown', () => {
                    displayInfo(x, z ,square);
                    highlightItem(x, z, false, type);
                });
                const graphics = new PIXI.Graphics();
                graphics.beginFill(color, 1);
                graphics.drawRect(0, 0, 25, 25);
                graphics.endFill();
                square.addChild(graphics);

                let imageUrl = '';
                switch (type) {
                    case 'User':
                        imageUrl = '/images/thumbnail_icona-operari.png';
                        break;
                    case 'Dock':
                        imageUrl = '/images/icona-door.png';
                        break;
                    case 'Buffer':
                        imageUrl = '/images/thumbnail_icona-buffer.png';
                        break;
                    case 'Location':
                        imageUrl = '/images/thumbnail_icona-estanteria-2.png';
                        break;
                    default:
                        imageUrl = '/images/thumbnail_icona-estanteria-2.png';
                }

                const image = new PIXI.Sprite.from(imageUrl);
                image.width = 25;
                image.height = 25;
                image.visible = !highlight; // La imagen no es visible si está resaltado
                square.image = image; // Guardar la imagen para referencia futura
                square.addChild(image);
                

                if (highlight) {
                    const highlightOverlay = new PIXI.Graphics();
                    highlightOverlay.isHighlightOverlay = true;
                    highlightOverlay.beginFill(0xffeb3b, 0.5);
                    highlightOverlay.drawRect(0, 0, 25, 25);
                    highlightOverlay.endFill();
                    square.addChild(highlightOverlay);
                }

                return square;
            }
            
            const warehouseData = !{JSON.stringify(warehouse)};
            //console.log(warehouseData);
            function createTiles() {
                // Verificar si warehouseData es un arreglo
                if (Array.isArray(warehouseData)) {
                    warehouseData.forEach((item) => {
                        // Verificar si el item es una ubicación (typeId === 6)
                        if (item.typeId !== null) {
                            // Verificar si el item tiene status
                            let statusIds = [];
                            if (item.status && Array.isArray(item.status)) {
                                statusIds = item.status.map(status => status.id);
                            } else if (item.status && typeof item.status === 'object') {
                                // Si item.status no es un arreglo pero es un objeto, supongamos que tiene un id
                                statusIds = [item.status.id];
                            }
                            //console.log(statusIds); // Verificar los statusIds
                            const square = createSquare(item.x, item.z, false, 0xffffff, item.id, statusIds);
                            mapContainer.addChild(square);
                        }
                    });
                }
            
                // Users
                const users = transformedData.filter(item => item.placeTypeCode === "User");
                users.forEach((user) => {
                    const square = createSquare(user.x, user.z, false, 'User');
                    mapContainer.addChild(square);
                });

                // Docks
                const docks = transformedData.filter(item => item.placeTypeCode === "Dock");
                docks.forEach((dock) => {
                    const square = createSquare(dock.x, dock.z, false, 'Dock');
                    mapContainer.addChild(square);
                });

                // Buffers
                const buffers = transformedData.filter(item => item.placeTypeCode === "Buffer");
                buffers.forEach((buffer) => {
                    const square = createSquare(buffer.x, buffer.z, false, 'Buffer');
                    mapContainer.addChild(square);
                });
            }


            function transformData(data) {
                return data.map(item => {
                    if (Array.isArray(item.status)) {
                        item.statusIds = item.status.map(status => status.id);
                    } else {
                        item.statusIds = [];
                    }
                    delete item.status;
                    return item;
                });
            }

            
            let currentMiniPanels = [];
            let currentHighlights = [];

            function highlightLocationsByState() {
                const stateSelector = document.getElementById('state-selector');
                const state = parseInt(stateSelector.value);
                const stateCode = stateSelector.options[stateSelector.selectedIndex].text;
                const locationsInState = [];

                // Eliminar todos los mini paneles existentes
                currentMiniPanels.forEach(panel => {
                    mapContainer.removeChild(panel);
                });
                currentMiniPanels = [];

                // Restaurar las ubicaciones resaltadas previamente
                currentHighlights.forEach(location => {
                    location.children.forEach(child => {
                        if (child.isHighlightOverlay) {
                            location.removeChild(child);
                        }
                    });
                    if (location.image) {
                        location.image.visible = true;
                    }
                });
                currentHighlights = [];

                function isOverlapping(newPanel, existingPanels) {
                    const newPanelBounds = newPanel.getBounds();
                    for (let panel of existingPanels) {
                        const panelBounds = panel.getBounds();
                        const overlap = !(newPanelBounds.right < panelBounds.left ||
                            newPanelBounds.left > panelBounds.right ||
                            newPanelBounds.bottom < panelBounds.top ||
                            newPanelBounds.top > panelBounds.bottom);
                        if (overlap) {
                            return true;
                        }
                    }
                    return false;
                }

                function findNonOverlappingPosition(panel, existingPanels) {
                    let offset = 55;
                    while (isOverlapping(panel, existingPanels)) {
                        panel.position.y -= offset;
                        offset += 55;
                    }
                }

                // Resaltar y mostrar información para ubicaciones con el estado seleccionado
                mapContainer.children.forEach(child => {
                    if (child.statusIds) {
                        const isStatePresent = child.statusIds.includes(state);
                        if (isStatePresent) {
                            // Resaltar superposición
                            const highlightOverlay = new PIXI.Graphics();
                            highlightOverlay.isHighlightOverlay = true;
                            highlightOverlay.beginFill(0xffeb3b, 0.5);
                            highlightOverlay.drawRect(0, 0, child.width, child.height);
                            highlightOverlay.endFill();
                            child.addChild(highlightOverlay);

                            // Mini panel con información de la ubicación
                            const miniPanel = new PIXI.Container();
                            const panelBackground = new PIXI.Graphics();
                            panelBackground.beginFill(0x000000, 0.7);
                            panelBackground.drawRect(0, 0, 100, 50);
                            panelBackground.endFill();
                            miniPanel.addChild(panelBackground);

                            const textStyle = new PIXI.TextStyle({
                                fontSize: 12,
                                fill: '#ffffff'
                            });
                            const locationInfo = new PIXI.Text(`Location: ${child.locationId}\nStatus: ${stateCode}`, textStyle);
                            locationInfo.position.set(5, 5);
                            miniPanel.addChild(locationInfo);
                             // Ajustar la posición vertical de los miniPanel
                            let offsetY = 55;
                            currentMiniPanels.forEach(panel => {
                                offsetY += 55; // Espacio fijo de 55 unidades
                            });
                            miniPanel.position.set(child.x, child.y - offsetY);
                            
                            findNonOverlappingPosition(miniPanel, currentMiniPanels);

                            mapContainer.addChild(miniPanel); // Añadir el mini panel al contenedor del mapa
                            currentMiniPanels.push(miniPanel);  // Almacenar la referencia del mini panel
                            locationsInState.push(child);
                            console.log(child.x,child.y);
                            highlightItem(child.x/25,child.y - (child.y-1));

                            // Ocultar la imagen si está disponible
                            if (child.image) {
                                child.image.visible = false;
                            }
                            currentHighlights.push(child);
                        }
                    }
                });

                // Actualizar el contador de estado
                const stateCount = document.getElementById('state-count');
                stateCount.textContent = `Count: ${locationsInState.length}`;
            }

            document.getElementById('state-selector').addEventListener('change', highlightLocationsByState);


            

            function isUser (x, z) {
                for (const item of transformedData) {
                    if (item.placeTypeCode === "User" && item.x === x && item.z === z) {
                        return true;
                    }
                }
                return false;
            }

            function isLocation(x, z) {
                for (const item of transformedData) {
                    if (Array.isArray(item.locations)) {
                        if (item.locations.some(location => location.x === x && location.z === z)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function isBuffer(x, z) {
                for (const item of transformedData) {
                    if (item.placeTypeCode === "Buffer" && item.x === x && item.z === z) {
                        return true;
                    }
                }
                return false;
            }

            function isDock(x, z) {
                for (const item of transformedData) {
                    if (item.placeTypeCode === "Dock" && item.x === x && item.z === z) {
                        return true;
                    }
                }
                return false;
            }

            function displayInfo(x, z) {
                const isUserSquare = isUser(x, z);
                const isLocationSquare = isLocation(x, z);
                const isBufferSquare = isBuffer(x, z);
                const isDockSquare = isDock(x, z);

                switch (true) {
                    case isUserSquare:
                        displayUserInfo(x, z);
                        break;
                    case isLocationSquare:
                        displayLocationInfo(x, z);
                        break;
                    case isBufferSquare:
                        displayBufferInfo(x, z);
                        break;
                    case isDockSquare:
                        displayDockInfo(x, z);
                        break;
                    default:
                        console.log("No information available for this element.");
                }
            }

            function displayUserInfo(x, z) {
                const locationDetails = document.getElementById('location-details');
                const userDetails = document.getElementById('user-details');
                locationDetails.style.display = 'block';
                locationDetails.innerHTML = '';
                userDetails.innerHTML = '';

                const user = transformedData.find(item => item.placeTypeCode === "User" && item.x === x && item.z === z);

                if (user) {
                    // Crear la tabla para la información del usuario
                    const userTable = document.createElement('table');
                    const userThead = document.createElement('thead');
                    const userTbody = document.createElement('tbody');
                    const userTrHead = document.createElement('tr');

                    const thId = document.createElement('th');
                    thId.textContent = 'User ID';
                    const thCode = document.createElement('th');
                    thCode.textContent = 'Code';
                    const thName = document.createElement('th');
                    thName.textContent = 'Name';
                    const thSurname = document.createElement('th');
                    thSurname.textContent = 'Surname';
                    const thPosition = document.createElement('th');
                    thPosition.textContent = 'Position';

                    userTrHead.appendChild(thId);
                    userTrHead.appendChild(thCode);
                    userTrHead.appendChild(thName);
                    userTrHead.appendChild(thSurname);
                    userTrHead.appendChild(thPosition);
                    userThead.appendChild(userTrHead);
                    userTable.appendChild(userThead);
                    userTable.appendChild(userTbody);

                    const userTrBody = document.createElement('tr');

                    const tdId = document.createElement('td');
                    tdId.textContent = user.id;
                    const tdCode = document.createElement('td');
                    tdCode.textContent = user.code;
                    const tdName = document.createElement('td');
                    tdName.textContent = user.name || 'N/A';
                    const tdSurname = document.createElement('td');
                    tdSurname.textContent = user.surname || 'N/A';
                    const tdPosition = document.createElement('td');
                    tdPosition.textContent = `| x = ${user.x} | y = ${user.y || 0} | z = ${user.z} |`;

                    userTrBody.appendChild(tdId);
                    userTrBody.appendChild(tdCode);
                    userTrBody.appendChild(tdName);
                    userTrBody.appendChild(tdSurname);
                    userTrBody.appendChild(tdPosition);
                    userTbody.appendChild(userTrBody);

                    // Carried Places
                    if (user.carriedPlaces && user.carriedPlaces.length > 0) {
                        const carriedPlacesHeader = document.createElement('tr');
                        carriedPlacesHeader.innerHTML = `<th colspan="5">Carried Places</th>`;
                        userTbody.appendChild(carriedPlacesHeader);

                        user.carriedPlaces.forEach(place => {
                            const trPlace = document.createElement('tr');
                            trPlace.innerHTML = `<td colspan="2">Code: ${place.code}</td><td colspan="3">Weight: ${place.weight}</td>`;
                            userTbody.appendChild(trPlace);
                        });
                    }

                    // Carried Stocks
                    if (user.carriedStocks && user.carriedStocks.length > 0) {
                        const carriedStocksHeader = document.createElement('tr');
                        carriedStocksHeader.innerHTML = `<th colspan="5">Carried Stocks</th>`;
                        userTbody.appendChild(carriedStocksHeader);

                        user.carriedStocks.forEach(stock => {
                            const trStock = document.createElement('tr');
                            trStock.innerHTML = `<td colspan="2">Code: ${stock.code}</td><td colspan="3">Quantity: ${stock.quantity}</td>`;
                            userTbody.appendChild(trStock);
                        });
                    }

                    // Orders
                    if (user.orders && user.orders.length > 0) {
                        const ordersHeader = document.createElement('tr');
                        ordersHeader.innerHTML = `<th colspan="5">Orders</th>`;
                        userTbody.appendChild(ordersHeader);

                        user.orders.forEach(order => {
                            const trOrder = document.createElement('tr');
                            trOrder.innerHTML = `
                                <td colspan="2">Code: ${order.code}</td>
                                <td colspan="3">Task Movements: ${order.taskmovements}</td>
                            `;
                            userTbody.appendChild(trOrder);
                        });
                    }

                    locationDetails.appendChild(userTable);

                    // Crear la tabla para el movimiento actual
                    const movementTable = document.createElement('table');
                    const movementThead = document.createElement('thead');
                    const movementTbody = document.createElement('tbody');
                    const movementTrHead = document.createElement('tr');

                    const thMovementId = document.createElement('th');
                    thMovementId.textContent = 'Movement ID';
                    const thPlaceFrom = document.createElement('th');
                    thPlaceFrom.textContent = 'Place From';
                    const thPlaceTo = document.createElement('th');
                    thPlaceTo.textContent = 'Place To';
                    const thProductCode = document.createElement('th');
                    thProductCode.textContent = 'Product Code';
                    const thProductDescription = document.createElement('th');
                    thProductDescription.textContent = 'Product Description';
                    const thQuantityToPick = document.createElement('th');
                    thQuantityToPick.textContent = 'Quantity to Pick';
                    const thConversionToPick = document.createElement('th');
                    thConversionToPick.textContent = 'Conversion to Pick';
                    const thOrder = document.createElement('th');
                    thOrder.textContent = 'Order';
                    const thClient = document.createElement('th');
                    thClient.textContent = 'Client';
                    const thTasksPending = document.createElement('th');
                    thTasksPending.textContent = 'Tasks Pending';
                    const thTasksDone = document.createElement('th');
                    thTasksDone.textContent = 'Tasks Done';

                    movementTrHead.appendChild(thMovementId);
                    movementTrHead.appendChild(thPlaceFrom);
                    movementTrHead.appendChild(thPlaceTo);
                    movementTrHead.appendChild(thProductCode);
                    movementTrHead.appendChild(thProductDescription);
                    movementTrHead.appendChild(thQuantityToPick);
                    movementTrHead.appendChild(thConversionToPick);
                    movementTrHead.appendChild(thOrder);
                    movementTrHead.appendChild(thClient);
                    movementTrHead.appendChild(thTasksPending);
                    movementTrHead.appendChild(thTasksDone);
                    movementThead.appendChild(movementTrHead);
                    movementTable.appendChild(movementThead);
                    movementTable.appendChild(movementTbody);

                    let hasTaskmovement = false;
                    user.orders.forEach(order => {
                        // Current Movement
                        if (order.currentTaskmovement) {
                            hasTaskmovement = true;
                            const movement = order.currentTaskmovement;
                            const trMovement = document.createElement('tr');
                            trMovement.innerHTML = `
                                <td>${movement.id}</td>
                                <td>${movement.placeFrom.code}</td>
                                <td>${movement.placeTo.code}</td>
                                <td>${movement.code}</td>
                                <td>${movement.description}</td>
                                <td>${movement.quantity}</td>
                                <td>${movement.conversion.quantity} ${movement.conversion.code}</td>
                                <td>${order.code}</td>
                                <td>${order.client.name}</td>
                                <td>${order.taskmovementsPending}</td>
                                <td>${order.taskmovementsDone}</td>
                            `;
                            movementTbody.appendChild(trMovement);
                        }
                    });

                     if (hasTaskmovement) {
                        userDetails.appendChild(movementTable);
                    } else {
                        userDetails.innerHTML = ''; 
                    }
                } else {
                    console.log("User not found.");
                }
            }



            function displayLocationInfo (x, z) {
                const locationDetails = document.getElementById('location-details');
                locationDetails.style.display = 'block';
                locationDetails.innerHTML = '';

                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                const trHead = document.createElement('tr');

                const thLocationCode = document.createElement('th');
                thLocationCode.textContent = 'Location Code';
                const thParentCode = document.createElement('th');
                thParentCode.textContent = 'Parent Code';
                const thPosition = document.createElement('th');
                thPosition.textContent = 'Position';
                const thInside = document.createElement('th');
                thInside.textContent = 'Inside';

                trHead.appendChild(thLocationCode);
                trHead.appendChild(thParentCode);
                trHead.appendChild(thPosition);
                trHead.appendChild(thInside);
                thead.appendChild(trHead);
                table.appendChild(thead);
                table.appendChild(tbody);

                transformedData.forEach(item => {
                    if (Array.isArray(item.locations)) {
                        item.locations.forEach(location => {
                            if (location.x === x && location.z === z) {
                                const trBody = document.createElement('tr');

                                const tdLocationCode = document.createElement('td');
                                tdLocationCode.textContent = location.code;
                                const tdParentCode = document.createElement('td');
                                const regex = /^[A-Za-z]\s*\d{6}$/;
                                const isStandardFormat = regex.test(location.code.replace(/\s/g, ''));
                                tdParentCode.textContent = isStandardFormat ? location.code.trim().charAt(0) : location.code;

                                const tdPosition = document.createElement('td');
                                tdPosition.textContent = `| x = ${location.x} | y = ${location.y || 0} | z = ${location.z} |`;

                                const tdInside = document.createElement('td');
                                const locationStocks = stocks.filter(stock => stock.placeId === location.id);
                                if (locationStocks.length > 0) {
                                    locationStocks.forEach(stock => {
                                        const product = products.find(product => product.id === stock.productId);
                                        if (product) {
                                            const productInfo = document.createElement('div');
                                            productInfo.textContent = `${product.name} = ${stock.quantity} Units`;
                                            tdInside.appendChild(productInfo);
                                        }
                                    });
                                } else {
                                    tdInside.textContent = 'No products found.';
                                }

                                trBody.appendChild(tdLocationCode);
                                trBody.appendChild(tdParentCode);
                                trBody.appendChild(tdPosition);
                                trBody.appendChild(tdInside);
                                tbody.appendChild(trBody);
                            }
                        });
                    }
                });

                locationDetails.appendChild(table);
            }

            function displayBufferInfo(x, z) {
                const locationDetails = document.getElementById('location-details');
                locationDetails.style.display = 'block';
                locationDetails.innerHTML = '';

                const buffer = transformedData.find(item => item.placeTypeCode === "Buffer" && item.x === x && item.z === z);

                if (buffer) {
                    const table = document.createElement('table');
                    const thead = document.createElement('thead');
                    const tbody = document.createElement('tbody');
                    const trHead = document.createElement('tr');

                    const thLocationCode = document.createElement('th');
                    thLocationCode.textContent = 'Buffer Code';
                    const thParentCode = document.createElement('th');
                    thParentCode.textContent = 'Parent Code';
                    const thPosition = document.createElement('th');
                    thPosition.textContent = 'Position';
                    const thInside = document.createElement('th');
                    thInside.textContent = 'Inside';

                    trHead.appendChild(thLocationCode);
                    trHead.appendChild(thParentCode);
                    trHead.appendChild(thPosition);
                    trHead.appendChild(thInside);
                    thead.appendChild(trHead);
                    table.appendChild(thead);
                    table.appendChild(tbody);

                    const trBody = document.createElement('tr');

                    const tdLocationCode = document.createElement('td');
                    tdLocationCode.textContent = buffer.code;
                    const tdParentCode = document.createElement('td');
                    const regex = /^[A-Za-z]\s*\d{6}$/;
                    const isStandardFormat = regex.test(buffer.code.replace(/\s/g, ''));
                    tdParentCode.textContent = isStandardFormat ? buffer.code.trim().charAt(0) : buffer.code;

                    const tdPosition = document.createElement('td');
                    tdPosition.textContent = `| x = ${buffer.x} | y = ${buffer.y || 0} | z = ${buffer.z} |`;

                    const tdInside = document.createElement('td');
                    const bufferStocks = stocks.filter(stock => stock.placeId === buffer.id);
                    if (bufferStocks.length > 0) {
                        bufferStocks.forEach(stock => {
                            const product = products.find(product => product.id === stock.productId);
                            if (product) {
                                const productInfo = document.createElement('div');
                                productInfo.textContent = `${product.name} = ${stock.quantity} Units`;
                                tdInside.appendChild(productInfo);
                            }
                        });
                    } else {
                        tdInside.textContent = 'No products found.';
                    }

                    trBody.appendChild(tdLocationCode);
                    trBody.appendChild(tdParentCode);
                    trBody.appendChild(tdPosition);
                    trBody.appendChild(tdInside);
                    tbody.appendChild(trBody);

                    locationDetails.appendChild(table);
                } else {
                    console.log("Buffer not found.");
                }
            }

            function displayDockInfo(x, z) {
                const locationDetails = document.getElementById('location-details');
                locationDetails.style.display = 'block';
                locationDetails.innerHTML = '';

                const dock = transformedData.find(item => item.placeTypeCode === "Dock" && item.x === x && item.z === z);

                if (dock) {
                    const table = document.createElement('table');
                    const thead = document.createElement('thead');
                    const tbody = document.createElement('tbody');
                    const trHead = document.createElement('tr');

                    const thLocationCode = document.createElement('th');
                    thLocationCode.textContent = 'Dock Code';
                    const thParentCode = document.createElement('th');
                    thParentCode.textContent = 'Parent Code';
                    const thPosition = document.createElement('th');
                    thPosition.textContent = 'Position';
                    const thInside = document.createElement('th');
                    thInside.textContent = 'Inside';

                    trHead.appendChild(thLocationCode);
                    trHead.appendChild(thParentCode);
                    trHead.appendChild(thPosition);
                    trHead.appendChild(thInside);
                    thead.appendChild(trHead);
                    table.appendChild(thead);
                    table.appendChild(tbody);

                    const trBody = document.createElement('tr');

                    const tdLocationCode = document.createElement('td');
                    tdLocationCode.textContent = dock.code;
                    const tdParentCode = document.createElement('td');
                    const regex = /^[A-Za-z]\s*\d{6}$/;
                    const isStandardFormat = regex.test(dock.code.replace(/\s/g, ''));
                    tdParentCode.textContent = isStandardFormat ? dock.code.trim().charAt(0) : dock.code;

                    const tdPosition = document.createElement('td');
                    tdPosition.textContent = `| x = ${dock.x} | y = ${dock.y || 0} | z = ${dock.z} |`;

                    const tdInside = document.createElement('td');
                    const dockStocks = stocks.filter(stock => stock.placeId === dock.id);
                    if (dockStocks.length > 0) {
                        dockStocks.forEach(stock => {
                            const product = products.find(product => product.id === stock.productId);
                            if (product) {
                                const productInfo = document.createElement('div');
                                productInfo.textContent = `${product.name} = ${stock.quantity} Units`;
                                tdInside.appendChild(productInfo);
                            }
                        });
                    } else {
                        tdInside.textContent = 'No products found.';
                    }

                    trBody.appendChild(tdLocationCode);
                    trBody.appendChild(tdParentCode);
                    trBody.appendChild(tdPosition);
                    trBody.appendChild(tdInside);
                    tbody.appendChild(trBody);

                    locationDetails.appendChild(table);
                } else {
                    console.log("Dock not found.");
                }
            }

            function findStockByProductId(productId) {
                return stocks.find(stock => stock.productId === productId);
            }

            window.searchProduct = function () {
                const productCode = document.getElementById('productCode').value.trim().toUpperCase();
                let found = false;

                // Buscar en productos
                const product = products.find(product => product.code.toUpperCase() === productCode);
                if (product) {
                    const stock = findStockByProductId(product.id);
                    if (stock) {
                        for (const item of transformedData) {
                            if (Array.isArray(item.locations)) {
                                const location = item.locations.find(loc => loc.id === stock.placeId);
                                if (location) {
                                    highlightItem(location.x, location.z, true, 'Location');
                                    displayLocationInfo(location.x, location.z);
                                    found = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                // Buscar en transformedData
                if (!found) {
                    for (const item of transformedData) {
                        if (item.code && item.code.toUpperCase() === productCode) {
                            if (item.placeTypeCode === 'User') {
                                highlightItem(item.x, item.z, true, 'User');
                                displayUserInfo(item.x, item.z);
                                found = true;
                            } else if (item.placeTypeCode === 'Dock') {
                                highlightItem(item.x, item.z, true, 'Dock');
                                displayDockInfo(item.x, item.z);
                                found = true;
                            } else if (item.placeTypeCode === 'Buffer') {
                                highlightItem(item.x, item.z, true, 'Buffer');
                                displayBufferInfo(item.x, item.z);
                                found = true;
                            }
                        }

                        // Buscar en ubicaciones anidadas
                        if (!found && Array.isArray(item.locations)) {
                            for (const location of item.locations) {
                                if (location.code && location.code.toUpperCase() === productCode) {
                                    highlightItem(location.x, location.z, true, 'Location');
                                    displayLocationInfo(location.x, location.z);
                                    found = true;
                                    break;
                                }
                            }
                        }

                        if (found) break;
                    }
                }

                if (!found) {
                    console.log(`Product not found: ${productCode}.`);
                }
            };



            window.autocompleteSearch = function () {
                let input = document.getElementById('productCode');
                let filter = input.value.toUpperCase();
                let ul = document.getElementById('autocomplete-results');
                ul.innerHTML = '';

                let suggestions = [];

                products.forEach(product => {
                    if (product.code.toUpperCase().startsWith(filter)) {
                        suggestions.push(product.code);
                    }
                });

                transformedData.forEach(item => {
                    if (item.code && item.code.toUpperCase().startsWith(filter)) {
                        suggestions.push(item.code);
                    }
                    if (Array.isArray(item.locations)) {
                        item.locations.forEach(location => {
                            if (location.code && location.code.toUpperCase().startsWith(filter)) {
                                suggestions.push(location.code);
                            }
                        });
                    }
                });

                suggestions = suggestions.slice(0, 4);

                suggestions.forEach(suggestion => {
                    let li = document.createElement('li');
                    li.textContent = suggestion;
                    li.onclick = function () {
                        input.value = suggestion;
                        ul.innerHTML = '';
                        searchProduct();
                    };
                    ul.appendChild(li);
                });
            };

            function highlightItem (x, z, center = false, type = 'default') {
                if (highlightedSquare) {
                    mapContainer.removeChild(highlightedSquare);
                }

                const elementType = type !== 'default' ? type : getElementType(x, z);
                highlightedSquare = createSquare(x, z, true, elementType);
                mapContainer.addChild(highlightedSquare);

                if (center) {
                    viewport.moveCenter(x * 25 + 12.5, z * 25 + 12.5);
                }
            }


            function getElementType (x, z) {
                switch (true) {
                    case isUser(x, z):
                        return 'User';
                    case isDock(x, z):
                        return 'Dock';
                    case isBuffer(x, z):
                        return 'Buffer';
                    case isLocation(x, z):
                        return 'Location';
                    default:
                        return 'default';
                }
            }

            function removeHighlightAtPosition(x, z) {
                currentHighlights.forEach((highlight, index) => {
                    if (highlight.x === x * 25 && highlight.y === z * 25) {
                        mapContainer.removeChild(highlight);
                        currentHighlights.splice(index, 1);
                    }
                });
            }


            document.addEventListener('click', function (event) {
                const autocompleteList = document.getElementById('autocomplete-results');
                if (!event.target.matches('#productCode')) {
                    autocompleteList.innerHTML = '';
                }
            });

            const stateSelector = document.getElementById('state-selector');
            placeStatusTypes.forEach(status => {
                const option = document.createElement('option');
                option.value = status.id;
                option.textContent = status.code;
                stateSelector.appendChild(option);
            });

            createTiles();

            const zoomInButton = document.getElementById('zoomIn');
            const zoomOutButton = document.getElementById('zoomOut');

            zoomInButton.addEventListener('click', () => {
                viewport.zoomPercent(0.1);
                console.log('Zoom In clicked');
            });

            zoomOutButton.addEventListener('click', () => {
                viewport.zoomPercent(-0.1);
                console.log('Zoom Out clicked');
            });

            const ordersCtx = document.getElementById('ordersChart').getContext('2d');
            const ordersChart = new Chart(ordersCtx, {
                type: 'pie',
                data: {
                    labels: workload.orderTotals.map(order => order.typeCode),
                    datasets: [{
                        data: workload.orderTotals.map(order => order.numOrders),
                        backgroundColor: ['red', 'blue', 'green', 'purple', 'orange'],
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (tooltipItem) {
                                    return `${tooltipItem.label}: ${tooltipItem.raw}`;
                                }
                            }
                        },
                        datalabels: {
                            color: '#fff',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            formatter: (value, ctx) => {
                                let label = ctx.chart.data.labels[ctx.dataIndex];
                                if (label.length > 6) {
                                    return label.substring(0, 5) + '...';
                                }
                                return label;
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

            const tasksCtx = document.getElementById('tasksChart').getContext('2d');
            const tasksChart = new Chart(tasksCtx, {
                type: 'pie',
                data: {
                    labels: workload.taskTotals.map(task => task.code),
                    datasets: [{
                        data: workload.taskTotals.map(task => task.numTasks),
                        backgroundColor: ['cyan', 'magenta', 'yellow', 'black'],
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (tooltipItem) {
                                    return `${tooltipItem.label}: ${tooltipItem.raw}`;
                                }
                            }
                        },
                        datalabels: {
                            color: '#fff',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            formatter: (value, ctx) => {
                                let label = ctx.chart.data.labels[ctx.dataIndex];
                                if (label.length > 6) {
                                    return label.substring(0, 5) + '...';
                                }
                                return label;
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

            const usersTasksCtx = document.getElementById('usersTasksChart').getContext('2d');
            const usersTasksChart = new Chart(usersTasksCtx, {
                type: 'pie',
                data: {
                    labels: workload.taskTotalsByUser
                        .filter(task => task.numTasks > 0)
                        .map(task => task.code),
                    datasets: [{
                        data: workload.taskTotalsByUser
                            .filter(task => task.numTasks > 0)
                            .map(task => task.numTasks),
                        backgroundColor: ['pink', 'green', 'lime', 'teal'],
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (tooltipItem) {
                                    return `${tooltipItem.label}: ${tooltipItem.raw}`;
                                }
                            }
                        },
                        datalabels: {
                            color: '#fff',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            formatter: (value, ctx) => {
                                let label = ctx.chart.data.labels[ctx.dataIndex];
                                if (label.length > 6) {
                                    return label.substring(0, 5) + '...';
                                }
                                return label;
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

