doctype html
html(lang="en")
    head
        meta(charset="UTF-8")
        title 2D Map with Pixi.js
        script(src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.4/browser/pixi.min.js" integrity="sha512-MLJM72M8frjnFXEvWn3NaVkrSxlDnbRK/Iwyr7loPca+13SdS9B5sNLHoIkDxfPOndP8WReNdwGLxisYUapc7A==" crossorigin="anonymous" referrerpolicy="no-referrer")
        script(src="https://cdn.jsdelivr.net/npm/pixi-viewport@4.30.0/dist/viewport.min.js")
        style.
            #autocomplete-container {
                position: relative;
                width: 40%;
            }

            #buttons {
                display: flex;
                justify-content: flex-end;
                width: 70%;
                margin-left: 3%;
            }

            #autocomplete-results {
                position: absolute;
                width: 300px;
                top: 100%;
                left: 0;
                right: 0;
                z-index: 1000;
                border: 1px solid #ddd;
                background: #fff;
                list-style-type: none;
                padding: 0;
                margin: 0;
                max-height: 120px;
                overflow-y: auto;
            }

            #autocomplete-results li {
                padding: 5px 10px;
                cursor: pointer;
            }

            #autocomplete-results li:hover {
                background-color: #f0f0f0;
            }

            body {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            canvas {
                width: 69%;
            }

            #product-interaction-section {
                display: flex;
                align-items: center;
                width: 68%;
            }

           #location-details, #user-details {
                display: inline-block; /* Para mostrar ambos contenedores en línea */
                vertical-align: top;   /* Alinear ambos contenedores en la parte superior */
                max-height: 500px;
                overflow-y: auto;
                border: 3px solid #ccc;
                padding: 10px;
                width: 60%;           /* Ajustar el ancho al contenido de la tabla */
            }

            #location-details {
                margin-right: 10px;    /* Espacio entre los dos contenedores */
            }

            #location-details table, #user-details table {
                width: 100%;
                border-collapse: collapse;
            }

            #location-details th, #user-details th, #location-details td, #user-details td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: center;
            }

            #location-details tr:nth-child(even), #user-details tr:nth-child(even) {
                background-color: #f2f2f2;
            }

            #location-details th, #user-details th {
                background-color: #4CAF50;
                color: white;
            }
            #pixi-canvas-container {
                display: flex;
                flex-direction: column-reverse;
                gap: 5%;
            }
            #title{
                display: flex;
                justify-content: center;
                margin-bottom: 20px;
            }

            #titleInfo{
                display: flex;
                justify-content: center;
                width: 32%;
            }
            #location-details-section{
                display: flex;
                height: auto;
            }


    body
        #title
            h1 Warehouse Map
        #location-details-section
            #product-interaction-section
                #autocomplete-container
                    input(type="text" id="productCode" placeholder="Enter product code" oninput="autocompleteSearch()")
                    ul#autocomplete-results
                    button(onclick="searchProduct()") Search

                #state-selector-container
                    select#state-selector
                    button(onclick="highlightLocationsByState()") Highlight Locations
                    span#state-count

                #buttons
                    button#zoomIn Zoom In
                    button#zoomOut Zoom Out


        #pixi-canvas-container
            #location-details
                table
                    thead
                        tr
                            th Location Code
                            th Parent Code
                            th Position
                            th Inside
                    tbody
            #titleInfo
                h2 Details
        #pixi-canvas-container
            #user-details
               

        script.
            const transformedData = transformData(!{JSON.stringify(data)});
            const products = !{JSON.stringify(productsData)};
            const stocks = !{JSON.stringify(stocksData)};
            const placeStatusTypes = !{JSON.stringify(placeStatusTypesData)};
            
            const app = new PIXI.Application({
                width: 1000,
                height: 500,
                backgroundColor: 0xffffff,
            });
            const canvasContainer = document.getElementById('pixi-canvas-container');
            canvasContainer.appendChild(app.view);

            app.view.style.border = '4px solid #000000';

            const viewport = new PIXI.Viewport({
                screenWidth: 1000,
                screenHeight: 500,
                worldWidth: 1000,
                worldHeight: 600,
                interaction: app.renderer.plugins.interaction
            });

            app.stage.addChild(viewport);

            viewport.drag().pinch().wheel().decelerate();

            const mapContainer = new PIXI.Container();
            viewport.addChild(mapContainer);

            function createSquare(x, z, highlight = false, color = 0xffffff, locationId = null, statusIds = []) {
                const square = new PIXI.Container();
                square.x = x * 25;
                square.y = z * 25;
                square.locationId = locationId;
                square.statusIds = statusIds; 
                square.interactive = true;
                square.on('pointerdown', () => displayInfo(x, z, square));

                const graphics = new PIXI.Graphics();
                graphics.beginFill(color, 1);
                graphics.drawRect(0, 0, 25, 25);
                graphics.endFill();
                square.addChild(graphics);

                if (highlight) {
                    const highlightOverlay = new PIXI.Graphics();
                    highlightOverlay.isHighlightOverlay = true;
                    highlightOverlay.beginFill(0xffeb3b, 0.5);
                    highlightOverlay.drawRect(0, 0, 25, 25);
                    highlightOverlay.endFill();
                    square.addChild(highlightOverlay);
                }

                const image = new PIXI.Sprite.from('/images/thumbnail_icona-estanteria-2.png');
                image.width = 25;
                image.height = 25;
                image.visible = !highlight; // La imagen no es visible si está resaltado
                square.image = image; // Guardar la imagen para referencia futura
                square.addChild(image);

                return square;
            }
            
            const warehouseData = !{JSON.stringify(warehouse)};
            console.log(warehouseData);
            function createTiles() {
                // Locations
               if (Array.isArray(warehouseData)) {
                warehouseData.forEach((item) => {
                    // Verificar si el item es una ubicación (typeId === 6)
                    if (item.typeId !== null) {
                        // Verificar si el item tiene status
                        let statusIds = [];
                        if (item.status && Array.isArray(item.status)) {
                            statusIds = item.status.map(status => status.id);
                        } else if (item.status && typeof item.status === 'object') {
                            // Si item.status no es un arreglo pero es un objeto, supongamos que tiene un id
                            statusIds = [item.status.id];
                        }
                        //console.log(statusIds); // Verificar los statusIds
                        const square = createSquare(item.x, item.z, false, 0xffffff, item.id, statusIds);
                        mapContainer.addChild(square);
                    }
                });
               }
                // Users
                const users = transformedData.filter(item => item.placeTypeCode === "User");
                console.log('Users:', users);
                users.forEach((user) => {
                    const color = 0x00ff00;
                    const square = createSquare(user.x, user.z, "user", color);
                    mapContainer.addChild(square);
                });

                // Docks
                transformedData.filter(item => item.placeTypeCode === "Dock").forEach((dock) => {
                    const color = 0xff0000;
                    const square = createSquare(dock.x, dock.z, "dock", color);
                    mapContainer.addChild(square);
                });

                // Buffers
                transformedData.filter(item => item.placeTypeCode === "Buffer").forEach((buffer) => {
                    const color = 0xff8000;
                    const square = createSquare(buffer.x, buffer.z, "buffer", color);
                    mapContainer.addChild(square);
                });
            }



            function transformData(data) {
                return data.map(item => {
                    if (Array.isArray(item.status)) {
                        item.statusIds = item.status.map(status => status.id);
                    } else {
                        item.statusIds = [];
                    }
                    delete item.status;
                    return item;
                });
            }

            
            let currentMiniPanels = [];
            let currentHighlights = [];

            function highlightLocationsByState() {
                const stateSelector = document.getElementById('state-selector');
                const state = parseInt(stateSelector.value);
                const stateCode = stateSelector.options[stateSelector.selectedIndex].text;
                const locationsInState = [];

                // Eliminar todos los mini paneles existentes
                currentMiniPanels.forEach(panel => {
                    mapContainer.removeChild(panel);
                });
                currentMiniPanels = [];

                // Restaurar las ubicaciones resaltadas previamente
                currentHighlights.forEach(location => {
                    // Eliminar la superposición de resaltado
                    location.children.forEach(child => {
                        if (child.isHighlightOverlay) {
                            location.removeChild(child);
                        }
                    });
                    // Restaurar la imagen original
                    if (location.image) {
                        location.image.visible = true;
                    }
                });
                currentHighlights = [];

                function isOverlapping(newPanel, existingPanels) {
                    const newPanelBounds = newPanel.getBounds();
                    for (let panel of existingPanels) {
                        const panelBounds = panel.getBounds();
                        const overlap = !(newPanelBounds.right < panelBounds.left ||
                            newPanelBounds.left > panelBounds.right ||
                            newPanelBounds.bottom < panelBounds.top ||
                            newPanelBounds.top > panelBounds.bottom);
                        if (overlap) {
                            return true;
                        }
                    }
                    return false;
                }

                function findNonOverlappingPosition(panel, existingPanels) {
                    let offset = 55;
                    while (isOverlapping(panel, existingPanels)) {
                        panel.position.y -= offset;
                        offset += 55;
                    }
                }

                // Resaltar y mostrar información para ubicaciones con el estado seleccionado
                mapContainer.children.forEach(child => {
                    if (child.statusIds) {
                        const isStatePresent = child.statusIds.includes(state);
                        if (isStatePresent) {
                            // Resaltar superposición
                            const highlightOverlay = new PIXI.Graphics();
                            highlightOverlay.isHighlightOverlay = true;
                            highlightOverlay.beginFill(0xffeb3b, 0.5);
                            highlightOverlay.drawRect(0, 0, child.width, child.height);
                            highlightOverlay.endFill();
                            child.addChild(highlightOverlay);

                            // Mini panel con información de la ubicación
                            const miniPanel = new PIXI.Container();
                            const panelBackground = new PIXI.Graphics();
                            panelBackground.beginFill(0x000000, 0.7);
                            panelBackground.drawRect(0, 0, 100, 50);
                            panelBackground.endFill();
                            miniPanel.addChild(panelBackground);

                            const textStyle = new PIXI.TextStyle({
                                fontSize: 12,
                                fill: '#ffffff'
                            });
                            const locationInfo = new PIXI.Text(`Location: ${child.locationId}\nStatus: ${stateCode}`, textStyle);
                            locationInfo.position.set(5, 5);
                            miniPanel.addChild(locationInfo);
                             // Ajustar la posición vertical de los miniPanel
                            let offsetY = 55;
                            currentMiniPanels.forEach(panel => {
                                offsetY += 55; // Espacio fijo de 55 unidades
                            });
                            miniPanel.position.set(child.x, child.y - offsetY);
                            
                            findNonOverlappingPosition(miniPanel, currentMiniPanels);

                            mapContainer.addChild(miniPanel); // Añadir el mini panel al contenedor del mapa
                            currentMiniPanels.push(miniPanel);  // Almacenar la referencia del mini panel
                            locationsInState.push(child);
                            console.log(child.x,child.y);
                            highlightItem(child.x/25,child.y - (child.y-1));

                            // Ocultar la imagen si está disponible
                            if (child.image) {
                                child.image.visible = false;
                            }
                            currentHighlights.push(child);
                        }
                    }
                });

                // Actualizar el contador de estado
                const stateCount = document.getElementById('state-count');
                stateCount.textContent = `Count: ${locationsInState.length}`;
            }

            // Listener para cambios en la selección del estado
            document.getElementById('state-selector').addEventListener('change', highlightLocationsByState);

            

            function isUser (x, z) {
                for (const item of transformedData) {
                    if (item.placeTypeCode === "User" && item.x === x && item.z === z) {
                        return true;
                    }
                }

                return false;
            }
            function isLocation (x, z) {
                for (const item of transformedData) {
                    if (Array.isArray(item.locations)) {
                        if (item.locations.some(location => location.x === x && location.z === z)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function isBuffer (x, z) {
                for (const item of transformedData) {
                    if (item.placeTypeCode === "Buffer" && item.x === x && item.z === z) {
                        return true;
                    }
                }

                return false;
            }

            function isDock (x, z) {

                for (const item of transformedData) {
                    if (item.placeTypeCode === "Dock" && item.x === x && item.z === z) {
                        return true;
                    }
                }
                return false;
            }

            function displayInfo (x, z) {
                const isUserSquare = isUser(x, z);
                const isLocationSquare = isLocation(x, z);

                switch (true) {
                    case isUserSquare:
                        elementType = "User";
                        displayUserInfo(x, z);
                        break;
                    case isLocationSquare:
                        elementType = "Location";
                        displayLocationInfo(x, z);
                        break;
                    default:
                        console.log("No information available for this square");
                        return;
                }

                const titleInfo = document.getElementById('titleInfo');
                titleInfo.querySelector('h2').textContent = `${elementType} Details`;
            }

            function displayUserInfo(x, z) {
                const locationDetails = document.getElementById('location-details');
                const userDetails = document.getElementById('user-details');
                locationDetails.innerHTML = '';
                userDetails.innerHTML = '';

                const user = transformedData.find(item => item.placeTypeCode === "User" && item.x === x && item.z === z);

                if (user) {
                    // Crear la tabla para la información del usuario
                    const userTable = document.createElement('table');
                    const userThead = document.createElement('thead');
                    const userTbody = document.createElement('tbody');
                    const userTrHead = document.createElement('tr');

                    const thId = document.createElement('th');
                    thId.textContent = 'User ID';
                    const thCode = document.createElement('th');
                    thCode.textContent = 'Code';
                    const thName = document.createElement('th');
                    thName.textContent = 'Name';
                    const thSurname = document.createElement('th');
                    thSurname.textContent = 'Surname';
                    const thPosition = document.createElement('th');
                    thPosition.textContent = 'Position';

                    userTrHead.appendChild(thId);
                    userTrHead.appendChild(thCode);
                    userTrHead.appendChild(thName);
                    userTrHead.appendChild(thSurname);
                    userTrHead.appendChild(thPosition);
                    userThead.appendChild(userTrHead);
                    userTable.appendChild(userThead);
                    userTable.appendChild(userTbody);

                    const userTrBody = document.createElement('tr');

                    const tdId = document.createElement('td');
                    tdId.textContent = user.id;
                    const tdCode = document.createElement('td');
                    tdCode.textContent = user.code;
                    const tdName = document.createElement('td');
                    tdName.textContent = user.name || 'N/A';
                    const tdSurname = document.createElement('td');
                    tdSurname.textContent = user.surname || 'N/A';
                    const tdPosition = document.createElement('td');
                    tdPosition.textContent = `| x = ${user.x} | y = ${user.y || 0} | z = ${user.z} |`;

                    userTrBody.appendChild(tdId);
                    userTrBody.appendChild(tdCode);
                    userTrBody.appendChild(tdName);
                    userTrBody.appendChild(tdSurname);
                    userTrBody.appendChild(tdPosition);
                    userTbody.appendChild(userTrBody);

                    // Carried Places
                    if (user.carriedPlaces && user.carriedPlaces.length > 0) {
                        const carriedPlacesHeader = document.createElement('tr');
                        carriedPlacesHeader.innerHTML = `<th colspan="5">Carried Places</th>`;
                        userTbody.appendChild(carriedPlacesHeader);

                        user.carriedPlaces.forEach(place => {
                            const trPlace = document.createElement('tr');
                            trPlace.innerHTML = `<td colspan="2">Code: ${place.code}</td><td colspan="3">Weight: ${place.weight}</td>`;
                            userTbody.appendChild(trPlace);
                        });
                    }

                    // Carried Stocks
                    if (user.carriedStocks && user.carriedStocks.length > 0) {
                        const carriedStocksHeader = document.createElement('tr');
                        carriedStocksHeader.innerHTML = `<th colspan="5">Carried Stocks</th>`;
                        userTbody.appendChild(carriedStocksHeader);

                        user.carriedStocks.forEach(stock => {
                            const trStock = document.createElement('tr');
                            trStock.innerHTML = `<td colspan="2">Code: ${stock.code}</td><td colspan="3">Quantity: ${stock.quantity}</td>`;
                            userTbody.appendChild(trStock);
                        });
                    }

                    // Orders
                    if (user.orders && user.orders.length > 0) {
                        const ordersHeader = document.createElement('tr');
                        ordersHeader.innerHTML = `<th colspan="5">Orders</th>`;
                        userTbody.appendChild(ordersHeader);

                        user.orders.forEach(order => {
                            const trOrder = document.createElement('tr');
                            trOrder.innerHTML = `
                                <td colspan="2">Code: ${order.code}</td>
                                <td colspan="3">Task Movements: ${order.taskmovements}</td>
                            `;
                            userTbody.appendChild(trOrder);
                        });
                    }

                    locationDetails.appendChild(userTable);

                    // Crear la tabla para el movimiento actual
                    const movementTable = document.createElement('table');
                    const movementThead = document.createElement('thead');
                    const movementTbody = document.createElement('tbody');
                    const movementTrHead = document.createElement('tr');

                    const thMovementId = document.createElement('th');
                    thMovementId.textContent = 'Movement ID';
                    const thPlaceFrom = document.createElement('th');
                    thPlaceFrom.textContent = 'Place From';
                    const thPlaceTo = document.createElement('th');
                    thPlaceTo.textContent = 'Place To';
                    const thProductCode = document.createElement('th');
                    thProductCode.textContent = 'Product Code';
                    const thProductDescription = document.createElement('th');
                    thProductDescription.textContent = 'Product Description';
                    const thQuantityToPick = document.createElement('th');
                    thQuantityToPick.textContent = 'Quantity to Pick';
                    const thConversionToPick = document.createElement('th');
                    thConversionToPick.textContent = 'Conversion to Pick';
                    const thOrder = document.createElement('th');
                    thOrder.textContent = 'Order';
                    const thClient = document.createElement('th');
                    thClient.textContent = 'Client';
                    const thTasksPending = document.createElement('th');
                    thTasksPending.textContent = 'Tasks Pending';
                    const thTasksDone = document.createElement('th');
                    thTasksDone.textContent = 'Tasks Done';

                    movementTrHead.appendChild(thMovementId);
                    movementTrHead.appendChild(thPlaceFrom);
                    movementTrHead.appendChild(thPlaceTo);
                    movementTrHead.appendChild(thProductCode);
                    movementTrHead.appendChild(thProductDescription);
                    movementTrHead.appendChild(thQuantityToPick);
                    movementTrHead.appendChild(thConversionToPick);
                    movementTrHead.appendChild(thOrder);
                    movementTrHead.appendChild(thClient);
                    movementTrHead.appendChild(thTasksPending);
                    movementTrHead.appendChild(thTasksDone);
                    movementThead.appendChild(movementTrHead);
                    movementTable.appendChild(movementThead);
                    movementTable.appendChild(movementTbody);

                    let hasTaskmovement = false;
                    user.orders.forEach(order => {
                        // Current Movement
                        if (order.currentTaskmovement) {
                            hasTaskmovement = true;
                            const movement = order.currentTaskmovement;
                            const trMovement = document.createElement('tr');
                            trMovement.innerHTML = `
                                <td>${movement.id}</td>
                                <td>${movement.placeFrom.code}</td>
                                <td>${movement.placeTo.code}</td>
                                <td>${movement.code}</td>
                                <td>${movement.description}</td>
                                <td>${movement.quantity}</td>
                                <td>${movement.conversion.quantity} ${movement.conversion.code}</td>
                                <td>${order.code}</td>
                                <td>${order.client.name}</td>
                                <td>${order.taskmovementsPending}</td>
                                <td>${order.taskmovementsDone}</td>
                            `;
                            movementTbody.appendChild(trMovement);
                        }
                    });

                     if (hasTaskmovement) {
                        userDetails.appendChild(movementTable);
                    } else {
                        userDetails.innerHTML = ''; 
                    }
                } else {
                    console.log("User not found.");
                }
            }



            function displayLocationInfo (x, z) {
                const locationDetails = document.getElementById('location-details');
                locationDetails.innerHTML = '';

                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                const trHead = document.createElement('tr');

                const thLocationCode = document.createElement('th');
                thLocationCode.textContent = 'Location Code';
                const thParentCode = document.createElement('th');
                thParentCode.textContent = 'Parent Code';
                const thPosition = document.createElement('th');
                thPosition.textContent = 'Position';
                const thInside = document.createElement('th');
                thInside.textContent = 'Inside';

                trHead.appendChild(thLocationCode);
                trHead.appendChild(thParentCode);
                trHead.appendChild(thPosition);
                trHead.appendChild(thInside);
                thead.appendChild(trHead);
                table.appendChild(thead);
                table.appendChild(tbody);

                transformedData.forEach(item => {
                    if (Array.isArray(item.locations)) {
                        item.locations.forEach(location => {
                            if (location.x === x && location.z === z) {
                                const trBody = document.createElement('tr');

                                const tdLocationCode = document.createElement('td');
                                tdLocationCode.textContent = location.code;
                                const tdParentCode = document.createElement('td');
                                const regex = /^[A-Za-z]\s*\d{6}$/;
                                const isStandardFormat = regex.test(location.code.replace(/\s/g, ''));
                                tdParentCode.textContent = isStandardFormat ? location.code.trim().charAt(0) : location.code;

                                const tdPosition = document.createElement('td');
                                tdPosition.textContent = `| x = ${location.x} | y = ${location.y || 0} | z = ${location.z} |`;

                                const tdInside = document.createElement('td');
                                const locationStocks = stocks.filter(stock => stock.placeId === location.id);
                                if (locationStocks.length > 0) {
                                    locationStocks.forEach(stock => {
                                        const product = products.find(product => product.id === stock.productId);
                                        if (product) {
                                            const productInfo = document.createElement('div');
                                            productInfo.textContent = `${product.name} = ${stock.quantity} Units`;
                                            tdInside.appendChild(productInfo);
                                        }
                                    });
                                } else {
                                    tdInside.textContent = 'No products found.';
                                }

                                trBody.appendChild(tdLocationCode);
                                trBody.appendChild(tdParentCode);
                                trBody.appendChild(tdPosition);
                                trBody.appendChild(tdInside);
                                tbody.appendChild(trBody);
                            }
                        });
                    }
                });

                locationDetails.appendChild(table);
            }



            function findStockByProductId (productId) {
                return stocks.find(stock => stock.productId === productId);
            }

            window.searchProduct = function () {
                const productCode = document.getElementById('productCode').value.trim().toUpperCase();

                let found = false;

                const product = products.find(product => product.code.toUpperCase() === productCode);
                if (product) {
                    found = true;
                    const stock = findStockByProductId(product.id);
                    if (stock) {
                        const location = transformedData.find(item => item.locations && item.locations.some(location => location.id === stock.placeId && location.placeTypeCode === 'Location'));
                        if (location) {
                            console.log(`Product found: ${productCode}. It will be highlighted`);
                            highlightItem(location.x, location.z);
                        } else {
                            console.log(`Location not found for product: ${productCode}.`);
                        }
                    } else {
                        console.log(`No stock found for product: ${productCode}.`);
                    }
                }

                if (!found) {
                    transformedData.forEach(item => {
                        if (item.code && item.code.toUpperCase() === productCode) {
                            found = true;
                            if (item.placeTypeCode === 'User' || item.placeTypeCode === 'Dock' || item.placeTypeCode === 'Buffer') {
                                console.log(`${productCode}. It will be highlighted`);
                                highlightItem(item.x, item.z);
                            }
                        } else if (item.locations) {
                            item.locations.forEach(location => {
                                if (location.code && location.code.toUpperCase() === productCode) {
                                    found = true;
                                    console.log(`Location found: ${productCode}. It will be highlighted`);
                                    highlightItem(location.x, location.z);
                                }
                            });
                        }
                    });
                }

                if (!found) {
                    console.log(`Product not found: ${productCode}.`);
                }
            };

            window.autocompleteSearch = function () {
                let input = document.getElementById('productCode');
                let filter = input.value.toUpperCase();
                let ul = document.getElementById('autocomplete-results');
                ul.innerHTML = '';

                let suggestions = [];

                products.forEach(product => {
                    if (product.code.toUpperCase().startsWith(filter)) {
                        suggestions.push(product.code);
                    }
                });

                transformedData.forEach(item => {
                    if (item.code && item.code.toUpperCase().startsWith(filter)) {
                        suggestions.push(item.code);
                    }
                    if (Array.isArray(item.locations)) {
                        item.locations.forEach(location => {
                            if (location.code && location.code.toUpperCase().startsWith(filter)) {
                                suggestions.push(location.code);
                            }
                        });
                    }
                });

                suggestions = suggestions.slice(0, 4);

                suggestions.forEach(suggestion => {
                    let li = document.createElement('li');
                    li.textContent = suggestion;
                    li.onclick = function () {
                        input.value = suggestion;
                        ul.innerHTML = '';
                        searchProduct();
                    };
                    ul.appendChild(li);
                });
            };

            function highlightItem(x, z) {
                removeHighlightAtPosition(x, z);
 
                const highlightColor = 0xffeb3b;
                const square = createSquare(x, z, true, highlightColor);
                mapContainer.addChild(square);
                viewport.moveCenter(x * 25 + 12.5, z * 25 + 12.5);

                currentHighlights.push(square);
            }

            function removeHighlightAtPosition(x, z) {
                currentHighlights.forEach((highlight, index) => {
                    if (highlight.x === x * 25 && highlight.y === z * 25) {
                        mapContainer.removeChild(highlight);
                        currentHighlights.splice(index, 1);
                    }
                });
            }


            document.addEventListener('click', function (event) {
                const autocompleteList = document.getElementById('autocomplete-results');
                if (!event.target.matches('#productCode')) {
                    autocompleteList.innerHTML = '';
                }
            });

            const stateSelector = document.getElementById('state-selector');
            placeStatusTypes.forEach(status => {
                const option = document.createElement('option');
                option.value = status.id;
                option.textContent = status.code;
                stateSelector.appendChild(option);
            });

            createTiles();

            const zoomInButton = document.getElementById('zoomIn');
            const zoomOutButton = document.getElementById('zoomOut');

            zoomInButton.addEventListener('click', () => {
                viewport.zoomPercent(0.1);
                console.log('Zoom In clicked');
            });

            zoomOutButton.addEventListener('click', () => {
                viewport.zoomPercent(-0.1);
                console.log('Zoom Out clicked');
            });

